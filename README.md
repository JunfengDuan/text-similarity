# 文本相似度计算（中文）

## Gensim 介绍

Gensim是一款开源的第三方Python工具包，用于从原始的非结构化的文本中，无监督地学习到文本隐层的主题向量表达。

它支持包括TF-IDF，LSA，LDA，BM25和word2vec在内的多种主题模型算法，支持流式训练，并提供了诸如相似度计算，信息检索等一些常用任务的API接口

## Installation

pip3 install --upgrade gensim

## Code dependencies

Python >= 3.6
NumPy >= 1.11.3
SciPy >= 0.18.1
Six >= 1.5.0
smart_open >= 1.2.1

## 程序说明

### 使用lsi模型：

主程序：run.py

1、对于文档集固定不变的情况：

先将模型和文档集转变成向量表示并缓存，cache_model_corpora()，其中raw_corpus.txt存放文档集

每次计算调用 text_similarity(text, num_best)


2、每次计算文档集会变的情况：

text_similarity(text, docs, num_best)

text：一个新文档

docs：文档集

num_best：返回最相似的文档数量

### 使用bm25算法：

主程序：demo.py

1、语料处理：分词、去停用词，并持久化到磁盘上（路径为：corpus_path）

   调用gen_corpus方法

2、计算相似度：
   调用 text_similarity方法

## 基本概念
语料（Corpus）：一组原始文本的集合，用于无监督地训练文本主题的隐层结构，语料中不需要人工标注的附加信息。
在Gensim中，Corpus是一个二维矩阵，每一次迭代返回一个可用于表达文本对象的稀疏向量。

词典（Dictionary）：是所有文档中所有单词的集合，而且记录了各词的出现次数等信息。

向量（Vector）：由一组文本特征构成的列表，是一段文本在Gensim中的内部表达。

模型（Model）：定义了两个向量空间的变换（即从文本的一种向量表达变换为另一种向量表达）。


## TF-IDF

在TF-IDF模型中，将每个词作为一个维度，所有词构成一个高维的语义空间，每个文档在这个空间中被映射为一个点。

## LSI（Latent Semantic Indexing）

LSI，即“隐含语义索引”模型。在TFIDF模型中，把每个词作为一个维度去构造特征空间，这样会割裂词与词之间的联系，损失语义信息。
所以在LSI模型中，我们把词和文档同等对待，把文本从稀疏的高维词汇空间映射到一个低维的向量空间，称之为潜语义空间，
每个词和每个文档都是被映射到这个空间中的一个点，文档的相似性在这个空间内进行比较，这样计算的概率是他们的联合概率。

LSI是基于奇异值分解（SVD）的方法来得到文本的主题。具体做法是：

1、将词和文档集转换成向量表示，词为列，文档为行，构造成Term-Document二维矩阵A，每个位置的值就是词在对应文档中的词频（也可以用tfidf值）。

2、对矩阵A作SVD分解，此时，A = US(V转置)。其中，S是特征值构成的对角矩阵，特征值代表其对应的特征向量的重要程度。

3、对SVD分解后的矩阵进行降维，只保留矩阵S前K个最大的奇异值得到S’。相应的U、V分别为U’、V’。 V’中的每行即为每个文档在潜在语义空间上的K维表示。

4、使用降维后的矩阵重建Term-Document矩阵A’ = U’S’(V’转置)。

5、对于一个列向量表示的新文档Q，其在潜在语义空间上的K维表示为Q’ = (Q转置)U’(S’逆)。

6、将新文档Q于文档集中的每个文档在潜在语义空间进行相似度计算，得到与Q最相似的文档。sim(Q,D)= qd/|q||d|.

## BM25(Best Matching-25th)

1、BM25是基于TF-IDF并做了改进的算法

2、对TF的改进:
    
传统的TF值理论上是可以无限大的。而BM25与之不同，它在TF计算方法中增加了一个常量k，用来限制TF值的增长极限。下面是两者的公式：

TF Score = ((k + 1) * tf) / (k + tf)

3、如何对待文档长度:

BM25还引入了平均文档长度的概念，单个文档长度(dl)对相关性的影响力与它的平均长度(avgDl)的比值有关系。BM25的TF公式里，除了k外，引入另外两个参数：

L和b。L是文档长度与平均长度的比值。如果文档长度是平均长度的2倍，则L＝2。b是一个常数，它的作用是规定L对评分的影响有多大。加了L和b的公式变为：

TF Score = ((k + 1) * tf) / (k * (1 - b + b * L) + tf)

4、IDF没有变化

IDF Score = log(N/(n+1))

4、相似度的计算：

参数b的作用是设定L对评分的影响有多大。如果把b设置为0，则L完全失去对评分的影响力。b的值越大，L对总评分的影响力越大。此时，相似度最终的完整公式为：

simlarity = IDF * ((k + 1) * tf) / (k * (1 - b + b * (dl/avgDl)) + tf)